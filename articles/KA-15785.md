---
title: Campaign Classic V7 - Ottimizza query SQL generata nella procedura guidata di aggiornamento del database
description: Descrizione
solution: Campaign,Campaign Classic v7
product: Campaign,Campaign Classic v7
applies-to: Campaign Classic,Campaign,Campaign Classic v7
keywords: KCS
resolution: Resolution
internal-notes: It can be helpful when dealing with database update issues with big tables
bug: true
article-created-by: Marta Zator
article-created-date: 5/5/2022 10:16:35 AM
article-published-by: Marta Zator
article-published-date: 5/5/2022 10:18:58 AM
version-number: 2
article-number: KA-15785
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e810bb6a-5ccc-ec11-a7b5-6045bd00dbbc
exl-id: 73e8701c-88e5-4b73-8c55-90eaee26d2ac
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '318'
ht-degree: 1%

---

# Campaign Classic V7 - Ottimizza query SQL generata nella procedura guidata di aggiornamento del database

## Descrizione


<b>Contesto e contesto:</b>
Nella maggior parte dei casi [!DNL Campaign] build, tra cui [!DNL Gold Standard] A 9032 potrebbero verificarsi diversi problemi quando si aggiungono nuove colonne a uno schema esistente.

L&#39;ambito di applicazione del presente articolo è quello di affrontare un problema specifico relativo a :

- Aggiunta di un campo intero a uno schema esistente quando i record esistono già.
- Ottimizzare la query SQL generata dall&#39;applicazione su una query efficiente per SQL Postgres.


<b>Caso di utilizzo:</b> 
<br>Abbiamo una tabella dei destinatari esistente o qualsiasi altra tabella che ha già oltre 1 milione di record.
<br>Ora è necessario aggiungere una colonna aggiuntiva alla tabella corrispondente al tipo di dati integer.
<br>Questa colonna viene aggiunta nella definizione dello schema e si desidera eseguire il commit delle modifiche nel database.

<b>Sfida </b>:
<br>Si verifica e si verifica un problema durante l&#39;aggiornamento del database e il database rileva un deadlock o la query blocca altre operazioni.
<br>Ciò è dovuto principalmente all&#39;aggiornamento di tutti i record a 0 in base al comando SQL generato dalla procedura guidata del database.


<br> <br>

## Risoluzione


Soluzione :

Quando si aggiunge una colonna intera , l&#39;istruzione SQL viene generata in questo modo:

```
ALTER TABLE NmsRecipient ADD column_name SMALLINT;
UPDATE NmsRecipient SET column_name = 0;
ALTER TABLE NmsRecipient ALTER COLUMN column_name SET Default 0;
ALTER TABLE NmsRecipient ALTER COLUMN icolumn_name SET NOT NULL;
```

Il problema è che ci sono 4 comandi eseguiti in parallelo nel database che possono causare problemi di prestazioni o un blocco critico.

La soluzione è quella di condensare questi 4 comandi in uno e comunque fare le stesse modifiche di seguito:

```
ALTER TABLE NmsRecipient ADD iFichierLiveDataCliqueurs SMALLINT NOT NULL SET Default 0 ;
```

Esegue tutte le modifiche necessarie, aggiungendo la colonna, impostando il valore predefinito, imposta `NOT NULL`e imposta anche il valore dei record esistenti su 0 a causa del `NOT NULL` vincolo.



<b>NOTA :</b>

Se è necessario aggiungere più colonne intere, aggiungerle una per una ed eseguire la procedura guidata del database per ogni modifica.

In questo modo si garantisce un funzionamento senza problemi, poiché l’istruzione aggiorna tutte le <b>esistente </b>registra a 0 e a seconda del no. di documenti che può richiedere tempo.
