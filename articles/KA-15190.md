---
title: "Incremental Query raccoglie tutti i record invece che solo quelli nuovi"
description: Descrizione
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# Incremental Query raccoglie tutti i record invece che solo quelli nuovi

## Descrizione

<b>Ambiente</b>
Campaign Classic


<b>Problema/Sintomi</b>
Le query incrementali non funzionano come previsto. Invece di raccogliere solo i nuovi record dall&#39;ultima esecuzione, vengono prelevati ogni volta tutti i record come una normale attività di query.


## Risoluzione


Questo problema è stato risolto nella versione 20.1.1 di Adobe Campaign Classic (a partire dalla build 9122).

<b>Soluzioni che i clienti possono utilizzare:</b>

<b>Soluzione alternativa 1</b>: Arrestare il flusso di lavoro di pulizia ed eseguirlo a intermittenza per pulire il database e l&#39;HDD fino a quando la correzione non viene presa e disponibile. Non è consigliabile se non disponi di un aggiornamento pianificato.

<b>Soluzione alternativa 2</b>: Supponiamo che l’attività di query incrementale sia interessata. Per aggirare il problema, eseguire la stessa operazione eseguita dalla query incrementale creando uno schema persistente che contenga il contenuto della tabella della cronologia. Utilizza una combinazione di attività di query e aggiornamento dati per simulare il comportamento. Sarà necessario eseguire questa operazione per tutti i flussi di lavoro che richiedono la query incrementale.

<b>Soluzione alternativa 3</b>:  Supponiamo che l’attività di query incrementale sia interessata. Per aggirare il problema, aggiungi un campo di controllo `tsCreated/tsLastModified` allo schema in questione. La query incrementale verrà quindi convertita in una normale attività di query con una clausola where come `tscreated GetDate()&#39;.

<b>Soluzione alternativa 4</b>:

1. Crea una nuova sequenza `xtknewworkflowid` e inizializzalo in un elemento molto lontano dagli intervalli workflowId correnti.
2. Modificare la `xtkworkflow` schema per l&#39;utilizzo `pkSequence`.
3. Chiedi al cliente di clonare tutti i flussi di lavoro interessati ed eliminare quelli originali.
4. Quando il cliente è pronto per un aggiornamento, rimuovi questa correzione ripristinando `xtknewId` per la creazione del flusso di lavoro (per evitare sorprese indesiderate).

<b>Causa</b>
Il colpevole è il flusso di lavoro di pulizia.

Il flusso di lavoro di query incrementale funziona in questo modo:

1. Mantiene una tabella di cronologia con i risultati delle iterazioni precedenti.
2. Recupera tutte le righe dalla query di destinazione.
3. Filtra tutte le righe presenti nella tabella di cronologia
4. Aggiunge i risultati rimanenti nella tabella di cronologia per il filtro di iterazione successivo.


Quindi, questo nome della tabella di marcia della storia è della seguente notazione:
`wkfhistoworkflowid` `activityName_`

Ora, per gli ID flusso di lavoro 0 (per i clienti in cui `xtknewid` consente sequenze negative), vediamo che in realtà è:

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.&quot;

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
