---
title: “Analizzare i problemi di memoria”
description: Descrizione
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: “KCS”
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 100%

---

# Analizzare i problemi di memoria

## Descrizione

<br>Sintomi<br><br>
L’applicazione [!DNL Java] è più lenta e alla fine esaurisce la memoria oppure l’utente visualizza un errore nei registri, nell’output della console `OutOfMemoryError: Java heap space` o l’errore `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>Causa<br><br>
Le cause di questi problemi possono essere molteplici.

Una possibile causa è che l’applicazione [!DNL Java], nel nostro caso CRX/CQ, è stata avviata dalla riga di comando con le impostazioni predefinite di memoria heap di [!DNL Java]. Questo significa che il parametro jvm `-Xmx` non è stato specificato. L’esecuzione di CRX o CQ richiede almeno 256 MB di heap assegnati. Se il problema è questo, parti dalla riga di comando e assicurati che le impostazioni della memoria heap siano impostate. Esempio:


```
java -Xmx512m -jar *.jar
```


In caso contrario, l’applicazione potrebbe mantenere troppi oggetti senza rilasciarli per la raccolta oggetti inattivi. Questo fenomeno è chiamato perdita di memoria. Per ulteriori informazioni, consulta [questa pagina](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html). Consulta la sezione seguente per informazioni su come analizzare i problemi di memoria nelle applicazioni Java.


## Risoluzione

Creare un’immagine heap<br><br>Generare automaticamente un’immagine heap<br><br>
Per creare automaticamente un’immagine heap quando la memoria è esaurita, puoi aggiungere il parametro jvm `-XX:+HeapDumpOnOutOfMemoryError` in modo da generare automaticamente un’immagine heap quando l’applicazione restituisce `OutOfMemoryError`. Ad esempio,


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


Questa operazione genera un file dell’immagine heap (`java_...hprof`) nella directory di lavoro del processo ogni volta che il processo `java` esaurisce la memoria. Il processo può continuare a funzionare anche dopo la generazione dell’immagine heap. Di solito un file dell’immagine heap è sufficiente per analizzare il problema.

<b>Nota:</b> se utilizzi lo script `crx-quickstart/server/start` per avviare l’istanza CRX, puoi aggiungere `-XX:+HeapDumpOnOutOfMemoryError` alla variabile `CQ_JVM_OPTS` (assicurati che anche la variabile sia priva di commenti). Ad esempio:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


Dopo aver aggiunto questo parametro e riavviato l’istanza CRX, verifica che la nuova opzione jvm sia impostata. Esegui `ps -ef | grep java` dalla riga di comando. Verifica quindi se visualizzi `-XX:+HeapDumpOnOutOfMemoryError` come parametro del processo `java` CRX.

Se a causa delle restrizioni di spazio su disco devi specificare una directory diversa per generare l’immagine heap, puoi aggiungere il parametro `-XX:HeapDumpPath=/path/to/generate/heapdump` in modo da segnalare a jvm la posizione in cui inserire il file.

Per un riferimento ai parametri jvm correlati al debug, consulta [questa pagina](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions).
<br><br>Generare manualmente un’immagine heap<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

Per generare manualmente un’immagine heap, esegui questo comando (jmap e jps si trovano nella cartella `bin` della home directory jdk):

1. Cerca il pid del processo `java` per il quale stai generando un’immagine heap.
   - In [!DNL Unix] o [!DNL Linux] puoi eseguire questa operazione con `ps -ef | grep java` o `jps -l`
   - Per eseguire questa operazione in [!DNL Windows], apri Gestione attività, premi `Ctrl+Shift+Esc` e vai su <b>Visualizza</b> > <b>Select Columns</b> (Seleziona colonne) > <b>PID (Process Identifier)</b> (PID (Identificatore processo)) o `jps -l`
2. Esegui il comando jmap seguente, sostituisci `/path/to/generate/heapdumpfile.hprof` con la posizione in cui desideri generare il file dell’immagine heap e sostituisci `1234` con il pid individuato nel passaggio precedente.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>JVM IBM</b>

Per generare le immagini corrette sul segnale utente, devi innanzitutto modificare le impostazioni JVM predefinite relative agli agenti Dump. Esistono diversi tipi di immagini, ma in generale hai bisogno dell’<b>immagine di sistema</b> completa per eseguire un’analisi approfondita della memoria. Aggiungi i seguenti argomenti:

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

Questo evento “utente” si verifica quando JVM riceve il segnale SIGQUIT ([!DNL Linux], AIX®, z/OS® e i5/OS™) o SIGBREAK ([!DNL Windows]) dal sistema operativo.

Per ulteriori informazioni, consulta la [documentazione del fornitore](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>Attenzione:</b> i file dell’immagine heap sono molto grandi e possono raggiungere le stesse dimensioni su disco della configurazione del parametro jvm `-Xmx` per heap massima. Assicurati di avere abbastanza spazio su disco nella directory in cui viene generato il file di immagine.
<br><br>Analizzare un’immagine heap<br><br>
Un buon strumento per analizzare le immagini heap è [!DNL Eclipse] MAT ([!DNL Eclipse Memory Analyzer]): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

Questo strumento non può analizzare le immagini generate da <b>JVM IBM</b>. Per eseguire questa operazione, ci sono diverse possibilità. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) funziona bene per le immagini heap in formato PHD o classico.

Per un’analisi completa dell’immagine di sistema, utilizza [IBM Support Assistant Workbench](http://www-01.ibm.com/software/support/isa/) con [IBM Monitoring and Diagnostic Tools for Java - Memory Analyzer versione 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) installato.
<br><br>Istogramma heap<br><br>
L’istogramma heap è una semplice misurazione del numero di oggetti attivi e della memoria utilizzata per la classe [!DNL Java]. Sfortunatamente, a seconda dell’installazione di [!DNL Java], gli strumenti richiesti potrebbero non essere disponibili o non funzionare sempre. Per creare un istogramma heap, devi innanzitutto disporre dell’ID del processo [!DNL Java]. Per ottenerlo esegui `ps` oppure, se disponibile, il comando seguente:


```
jps -l
```


Questo strumento [!DNL Java] consente di recuperare gli ID processo di tutti i processi [!DNL Java] in esecuzione. Esempio:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


Adesso esegui il comando seguente:


```
jmap -histo 3313
```


L’elenco è ordinato in base alla memoria totale richiesta (superficiale, escludendo gli oggetti di riferimento). Le prime 20 righe dell’output sono le più interessanti. Esempio di output:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>Informazioni aggiuntive</b>

Per agevolare l’analisi del problema è utile conoscere anche le informazioni seguenti:

- Versione di CRX o CQ, incluso un elenco di tutti i numeri di versione delle correzioni rapide installate.
- Sistema operativo, fornitore JVM e versione.


<b>Riferimenti</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
