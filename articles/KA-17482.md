---
title: "Analizza problemi di memoria"
description: Descrizione
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 1%

---

# Analisi dei problemi di memoria

## Descrizione

<br>Sintomi<br><br>
La [!DNL Java] l&#39;applicazione è più lenta e alla fine esaurisce la memoria oppure si verifica un errore nei log o nell&#39;output della console `OutOfMemoryError: Java heap space` o `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>Causa<br><br>
Tali problemi possono avere molte cause.

Una possibile causa è che [!DNL Java] applicazione, nel nostro caso, CRX / CQ è stato avviato dalla riga di comando con le impostazioni predefinite di memoria heap di [!DNL Java]. Questo significa che il parametro jvm `-Xmx` non specificato. CRX o CQ hanno bisogno di almeno 256 MB di heap assegnati per l&#39;esecuzione. Se questo è il problema, quindi partendo dalla riga di comando, assicurati che le impostazioni della memoria heap siano impostate. Esempio:


```
java -Xmx512m -jar *.jar
```


In caso contrario, l&#39;applicazione potrebbe mantenere troppi oggetti senza rilasciarli per Garbage Collection. Questa è chiamata perdita di memoria, vedi [qui](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html) per ulteriori informazioni. Vedi la sezione seguente su come analizzare i problemi di memoria nelle applicazioni java.


## Risoluzione

Creare un’immagine heap<br><br>Genera automaticamente un’immagine heap<br><br>
Per creare automaticamente un’immagine heap quando la memoria è esaurita, puoi aggiungere il parametro jvm `-XX:+HeapDumpOnOutOfMemoryError` per generare automaticamente un’immagine heap quando l’applicazione genera un’ `OutOfMemoryError`. Esempio,


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


Questo genera un file immagine heap (`java_...hprof`) nella directory di lavoro del processo ogni volta che `java` memoria esaurita del processo. Il processo può continuare a essere eseguito dopo la generazione dell’immagine heap. Di solito, un file immagine heap è sufficiente per analizzare il problema.

<b>Nota:</b> se utilizzi `crx-quickstart/server/start` script per avviare la tua istanza CRX, quindi puoi aggiungere `-XX:+HeapDumpOnOutOfMemoryError` al `CQ_JVM_OPTS` (assicurati che anche la variabile non abbia alcun commento). Esempio:


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


Dopo aver aggiunto questo parametro e riavviato l&#39;istanza CRX, verifica che la nuova opzione jvm sia impostata. Esegui `ps -ef | grep java` dalla riga di comando. Quindi controlla se vedi `-XX:+HeapDumpOnOutOfMemoryError` come parametro del CRX `java` processo.

Se è necessario specificare una directory diversa per generare l&#39;immagine heap a causa delle restrizioni di spazio su disco, è possibile aggiungere la `-XX:HeapDumpPath=/path/to/generate/heapdump` per dire al jvm dove mettere il file.

Vedi [qui](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) per un riferimento ai parametri jvm correlati al debug.
<br><br>Generare manualmente un’immagine heap<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

Per generare manualmente un’immagine heap, esegui questo comando (jmap e jps si trovano in `bin` cartella della home directory jdk):

1. cerca il pid del `java` processo per il quale stai generando un’immagine heap.
   - In [!DNL Unix] o [!DNL Linux] questo può essere fatto con `ps -ef | grep java` o `jps -l`
   - In [!DNL Windows] questo può essere fatto aprendo task manager, premere `Ctrl+Shift+Esc` vai a <b>Visualizza</b> = <b>Seleziona colonne</b> = <b>PID (Process Identifier)</b> o `jps -l`
2. Esegui il comando jmap qui sotto, sostituisci `/path/to/generate/heapdumpfile.hprof` con la posizione in cui desideri generare il file immagine heap e sostituisci `1234` con il pid che hai cercato nel passaggio precedente.

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>JVM IBM</b>

Per generare le immagini corrette sul segnale utente, devi innanzitutto modificare le impostazioni JVM predefinite per quanto riguarda gli agenti Dump. Ci sono diversi tipi di immagini, ma in generale hai bisogno del pieno <b>dump di sistema</b> per eseguire un&#39;analisi approfondita della memoria. Aggiungi i seguenti argomenti:

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

Questo evento &quot;utente&quot; si verifica quando la JVM riceve il SIGQUIT ([!DNL Linux], AIX®, z/OS® e i5/OS™ o SIGBREAK ([!DNL Windows]) dal sistema operativo.

Per ulteriori informazioni, consulta la documentazione del fornitore [qui](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>Avviso:</b> I file immagine heap sono grandi e possono avere le stesse dimensioni su disco del heap massimo `-Xmx` configurazione del parametro jvm. Assicurati di avere spazio su disco sufficiente assegnato alla directory in cui viene generato il file di dump.
<br><br>Analizza immagine heap<br><br>
Un buon strumento per analizzare le immagini di heap è [!DNL Eclipse] MAT ([!DNL Eclipse Memory Analyzer]): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

Questo strumento non può analizzare <b>JVM IBM</b> immagini generate. Per quelle, ci sono diverse possibilità. [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) andrà bene per le immagini heap in formato PHD o classico.

Per un&#39;analisi completa dell&#39;immagine di sistema, utilizza il [Workbench Assistente all’assistenza per IBM](http://www-01.ibm.com/software/support/isa/) con [Strumenti di monitoraggio e diagnostica di IBM per Java - Memory Analyzer versione 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) installato in alto.
<br><br>Istogramma heap<br><br>
L’istogramma heap è una semplice misurazione del numero di oggetti live e della memoria utilizzata per [!DNL Java] classe. Sfortunatamente, a seconda del [!DNL Java] installazione, gli strumenti richiesti potrebbero non essere disponibili o non funzionare sempre. Per creare un istogramma heap, è innanzitutto necessario l’ID di processo del [!DNL Java] processo. Per ottenerlo, esegui `ps` oppure (se disponibile), eseguire:


```
jps -l
```


Questo [!DNL Java] lo strumento ottiene gli id del processo di tutto in esecuzione [!DNL Java] processi. Esempio:


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


Esegui ora il comando seguente:


```
jmap -histo 3313
```


L&#39;elenco è ordinato in base alla memoria totale richiesta (superficiale: escludendo gli oggetti di riferimento). Le prime 20 linee dell&#39;output sono le più interessanti. Esempio di output:


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>Informazioni aggiuntive</b>

Per aiutare ad analizzare il problema, dobbiamo anche conoscere le seguenti informazioni:

- Versione CRX o CQ, incluso un elenco di tutti gli hotfix installati numero di versione.
- Sistema operativo, fornitore JVM e versione.


<b>Riferimenti</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
