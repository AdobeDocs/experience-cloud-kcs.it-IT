---
title: Informazioni sulla memorizzazione in cache
description: Descrizione
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: 2/7/2022 5:13:07 PM
article-published-by: Roxann McGlumphy
article-published-date: 2/7/2022 5:13:28 PM
version-number: 3
article-number: KA-17912
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ee0f4935-3988-ec11-93b0-0022480837ff
exl-id: a5da3fc9-c0a0-4d5a-8369-a96dad9e2b49
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '1462'
ht-degree: 1%

---

# Informazioni sulla memorizzazione in cache

## Descrizione

Questo documento spiegherà come [!DNL dispatcher] la memorizzazione in cache viene eseguita e come può essere configurata<br><br>
[Sommario](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html)

## Risoluzione


<b>Directory di memorizzazione nella cache</b>

Utilizziamo le seguenti directory di cache predefinite nelle installazioni della linea di base

- Autore

   - `/mnt/var/www/author`
- Autore

   - `/mnt/var/www/html`


Quando ogni richiesta attraversa il [!DNL dispatcher] le richieste seguono le regole configurate per mantenere una versione cache locale per rispondere agli elementi idonei

<b>Nota:</b>

Manteniamo intenzionalmente il carico di lavoro pubblicato separato dal carico di lavoro dell&#39;autore perché quando Apache cerca un file nel DocumentRoot non sa da quale istanza AEM provenga. Pertanto, anche se la cache è disabilitata nella farm dell’autore, se DocumentRoot dell’autore è uguale a quella dell’editore, i file della cache vengono distribuiti quando presente. Ciò significa che distribuirai i file dell’autore per dalla cache pubblicata e produrrai un’esperienza di mix davvero terribile per i tuoi visitatori. Anche mantenere directory DocumentRoot separate per contenuti pubblicati diversi è una pessima idea. Sarà necessario creare più elementi nella cache che non differiscono tra siti come clientlibs, nonché impostare un agente di flush di replica per ogni DocumentRoot configurato. Incremento della quantità di scaricamento in head con ogni attivazione di pagina. Utilizza lo spazio dei nomi dei file e i percorsi completi nella cache ed evita più DocumentRoot per i siti pubblicati.



<b>File di configurazione</b>

[!DNL Dispatcher] controlla ciò che si qualifica come memorizzabile in cache nel `/cache {` di qualsiasi file farm. 
Nelle farm di configurazione della linea di base AMS, troverai i nostri &quot;include&quot; come mostrato di seguito:


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


Quando crei le regole per cosa memorizzare in cache o meno, fai riferimento alla documentazione [qui](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>Creazione di cache</b>

Abbiamo visto molte implementazioni in cui le persone non memorizzano in cache i contenuti di authoring. 
Stanno perdendo un enorme miglioramento delle prestazioni e della reattività per i loro autori.

Parliamo della strategia adottata per configurare la farm degli autori in modo che venga memorizzata correttamente nella cache.

Di seguito è riportato un autore di base `/cache {` sezione del file farm dell’autore:


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


Le cose importanti da notare qui sono che <b>`/docroot`</b> è impostato sulla directory cache per l’autore.

<b>Nota:</b>

Assicurati che `DocumentRoot` nel `.vhost` il file corrisponde alle farm `/docroot` parameter

L’istruzione &quot;include&quot; delle regole di cache include il file <b>`/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any`</b> che contiene le seguenti regole:


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


In uno scenario di authoring, il contenuto cambia continuamente e di proposito. Desideri memorizzare nella cache solo gli elementi che non verranno modificati frequentemente.
Abbiamo delle regole da memorizzare nella cache `/libs` poiché fanno parte della linea di base AEM installare e cambierebbero fino a quando non avrai installato Service Pack, Cumulative Fix Pack, Upgrade o Hotfix. La memorizzazione in cache di questi elementi ha un senso e offre enormi vantaggi all&#39;esperienza di authoring degli utenti finali che utilizzano il sito.

<b>Nota:</b>

Tieni presente che anche queste regole memorizzano nella cache <b>`/apps`</b> è qui che vive il codice dell&#39;applicazione personalizzata. Se stai sviluppando il codice su questa istanza, allora si rivelerà molto confuso quando salvi il file e non vedi se riflette nell&#39;interfaccia utente perché serve una copia in cache. In questo caso, se distribuisci il codice in AEM, anche questo non è frequente e parte dei passaggi di distribuzione dovrebbe essere la cancellazione della cache dell’autore. Anche in questo caso il vantaggio è enorme, rendendo il codice memorizzabile nella cache più veloce per gli utenti finali.



<b>ServeOnStale (Servizio AKA su Stale / SOS)</b>

Questa è una delle gemme di una caratteristica del [!DNL dispatcher]. Se l’editore è sotto carico o non risponde, in genere genera un codice di risposta http 502 o 503. Se questo accade e questa funzione viene attivata, la [!DNL dispatcher] verrà istruito per continuare a servire ciò che il contenuto è ancora nella cache come miglior tentativo, anche se non è una nuova copia. È meglio servire qualcosa se ce l&#39;hai invece di mostrare un messaggio di errore che non offre funzionalità.

<b>Nota:</b>

Tieni presente che se il renderer dell’editore dispone di un timeout del socket o di un messaggio di errore 500, questa funzione non verrà attivata. Se AEM non è raggiungibile, questa funzione non funziona

Questa impostazione può essere impostata in qualsiasi farm, ma ha senso applicarla solo ai file farm di pubblicazione. Ecco un esempio di sintassi della funzione abilitata in un file farm:


```
/cache { 
    /serveStaleOnError "1"
```




<b>Memorizzazione in cache di pagine con parametri di query/argomenti</b>

<b>Nota:</b>

Uno dei comportamenti normali del [!DNL Dispatcher] Il modulo è che se una richiesta ha un parametro di query nell’URI (generalmente mostrato come `/content/page.html?myquery=value`) salterà la memorizzazione in cache del file e andrà direttamente all&#39;istanza AEM. Considera questa richiesta come una pagina dinamica e non dovrebbe essere memorizzata nella cache. Questo può causare effetti sull’efficienza della cache.

Se hai pagine in AEM che prendono `GET` argomenti / parametri di query nella riga dell&#39;indirizzo che aiutano il funzionamento della pagina ma non rendono html diversi sono buoni candidati per questo elemento di configurazione Puoi dire [!DNL dispatcher] quali argomenti ignorare e comunque memorizzare la pagina nella cache.
Ad esempio, qualcuno ha creato un meccanismo di riferimento per i collegamenti profondi dei social media che utilizza il riferimento all’argomento nell’URI per sapere da dove proviene la persona.

<b>Esempio di utilizzo:</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

La pagina è memorizzabile nella cache al 100%, ma non memorizza in cache perché gli argomenti sono presenti. 
Per risolvere questo problema, aggiungiamo la seguente sezione al file di configurazione della farm:


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


Ora quando [!DNL dispatcher] visualizza la richiesta ignorerà il fatto che la richiesta ha il parametro di query di ?reference e memorizza comunque la pagina in cache



<b>Memorizzazione in cache delle intestazioni di risposta</b>

È piuttosto ovvio che la [!DNL dispatcher] cache `.html` pagine e clientlibs, ma sapevi che può anche memorizzare nella cache particolari intestazioni di risposta lungo il contenuto di un file con lo stesso nome ma con un `.h` estensione file. Questo consente la risposta successiva non solo al contenuto, ma anche alle intestazioni di risposta che dovrebbero accompagnarlo dalla cache.

AEM può gestire più di una semplice codifica UTF-8

A volte gli elementi hanno intestazioni speciali che aiutano a controllare i dettagli di codifica del TTL della cache e gli ultimi timestamp modificati.

Questi valori quando vengono memorizzati nella cache, vengono rimossi per impostazione predefinita e [!DNL apache] Il server web httpd eseguirà il proprio lavoro di elaborazione della risorsa con i suoi normali metodi di gestione dei file, che normalmente si limita all’indovinazione dei tipi di mime in base alle estensioni dei file.

Se hai [!DNL dispatcher] memorizza in cache la risorsa e le intestazioni desiderate per esporre l&#39;esperienza corretta e garantire che tutti i dettagli lo facciano al browser dei client.

Ecco un esempio di farm con le intestazioni da memorizzare nella cache specificate:


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


Nell’esempio che hanno configurato AEM per servire le intestazioni, la rete CDN cerca di sapere quando annullare la validità della cache. Ciò significa che ora AEM in modo appropriato determinare quali file vengono invalidati in base alle intestazioni.

<b>Nota:</b>

Tieni presente che non puoi utilizzare espressioni regolari o corrispondenze globali. È una lista letterale delle intestazioni da memorizzare in cache. Inserisci solo un elenco delle intestazioni letterali che desideri memorizzare in cache.



<b>Periodo di tolleranza per annullamento automatico validità</b>

Nei sistemi AEM che svolgono molte attività da parte degli autori che eseguono molte attivazioni di pagina è possibile avere una race condition in cui si verificano ripetuti invalidamenti. Le richieste di scaricamento ripetute in modo significativo non sono necessarie e puoi generare una certa tolleranza per non ripetere uno scaricamento finché il periodo di tolleranza non viene cancellato.

<b>Esempio di funzionamento:</b>

Se hai 5 richieste di annullamento della validità `/content/exampleco/en/` tutto avviene in un periodo di 3 secondi.

Con questa funzione disattivata, invalideresti la directory della cache `/content/exampleco/en/` 5 volte

Attivando questa funzione e impostandola su 5 secondi, invaliderebbe la directory della cache `/content/exampleco/en/` <b>una volta</b>

Ecco un esempio di sintassi di questa funzione configurata per un periodo di tolleranza di 5 secondi:


```
/cache { 
    /gracePeriod "5"
```




<b>Invalidazione basata su TTL</b>

Una nuova funzione del [!DNL dispatcher] modulo <b>Time to Live (TTL)</b> opzioni di invalidazione basate per gli elementi memorizzati nella cache. Quando un elemento viene memorizzato nella cache, cerca la presenza di intestazioni di controllo della cache e genera un file nella directory della cache con lo stesso nome e un <b>`.ttl`</b> estensione.

Ecco un esempio della funzione configurata nel file di configurazione della farm:


```
/cache { 
    /enableTTL "1"
```


<b>Nota:</b>

Tieni presente che AEM deve essere ancora configurato per inviare intestazioni TTL per [!DNL dispatcher] per onorarli. L&#39;attivazione di questa funzione abilita solo la funzione [!DNL dispatcher] per sapere quando rimuovere i file per i quali AEM inviare le intestazioni di controllo cache. Se AEM non inizia a inviare intestazioni TTL, allora [!DNL dispatcher] Non farò niente di speciale qui.



<b>Regole filtro cache</b>

Ecco un esempio di configurazione della linea di base per cui gli elementi devono essere memorizzati nella cache su un editore:


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


Vogliamo rendere il nostro sito pubblicato più greedy possibile e memorizzare in cache tutto.

Se ci sono elementi che interrompono l&#39;esperienza quando è presente nella cache, puoi aggiungere regole per rimuovere l&#39;opzione per memorizzare in cache quell&#39;elemento. Come vedi nell’esempio precedente, i token csrf non dovrebbero mai essere memorizzati nella cache e sono stati esclusi. Ulteriori dettagli sulla stesura di queste regole sono disponibili [qui](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)
