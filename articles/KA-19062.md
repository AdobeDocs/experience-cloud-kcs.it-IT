---
title: Come eseguire il debug di SegmentNotFoundException quando il problema è segnalato in AEM 6.x
description: Descrizione
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# Come eseguire il debug di SegmentNotFoundException quando il problema è segnalato in AEM 6.x

## Descrizione


<b>Come eseguire il debug di SegmentNotFoundException quando il problema è segnalato in AEM 6.x</b>

A <b>SegmentNotFoundException</b> nel registro degli errori indica che un segmento non è più presente, anche se qualcuno tenta comunque di accedervi. Le cause principali sono sostanzialmente tre: il segmento è stato rimosso con un intervento manuale (ad esempio rm -rf /), il segmento è stato rimosso con la revisione della raccolta degli oggetti inattivi o il segmento non può essere trovato a causa di qualche bug nel codice.

Ci potrebbe essere un&#39;eccezione come il seguente potrebbe essere visto nei log:

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException: Segmento d2c720c4-c146-4ab1-ac37-542aad93c33f non trovato su org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602) su org.apache.jackrabbit.oak ak.segment.file.FileStore$8.call(FileStore.java:542) su org.apache.jackrabbit.oak.segment.SegmentCache.getSegment(SegmentCache.java:95) su org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:54 2) su org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) su org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) su org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:424) su org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) su org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) su org.apache.jackrabbit.oak.segment.SegmentNodeState.compare BaseState(SegmentNodeState.java:608) su org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) su org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java 442) su org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) su org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) su org.apache.jackrabbit.oak.segment.SegmentNodeState.compareAgainst BaseState(SegmentNodeState.java:608) su org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) su org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.java:69 5) su org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPermitted(AsyncIndexUpdate.java:543) su org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402) su org.apache.sache ling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobExecutor.java:118) su org.quartz.core.JobRunShell.run(JobRunShell.java:202) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) a java.util.concurrent.threadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) a java.lang.Thread.run(Thread.java:745)

...


## Risoluzione


Ci sono 2 approcci che possiamo seguire per risolvere il problema e rimuovere le incongruenze nell&#39;archivio descritto di seguito nelle sezioni A e B.

<b>A. Torna all&#39;ultima revisione valida nota dell&#39;archivio segmenti.</b>

In primo luogo, dovremmo utilizzare lo strumento oak run che è un jar1 eseguibile che contiene tutto il necessario per una semplice installazione Oak e l&#39;esecuzione di operazioni correlate oak.

La modalità di esecuzione del controllo di oak-run può essere utilizzata per determinare l&#39;ultima revisione valida nota di un archivio segmenti.  Può essere utilizzato per ripristinare manualmente un archivio di segmenti corrotti alla sua ultima revisione valida.

*Attenzione: Questo processo riporta i dati nel sistema a un punto precedente.  Se desideri evitare di perdere le modifiche nel sistema, puoi provare l&#39;opzione B qui sotto.*

Per eseguire il controllo e il ripristino:

1. Scarica una versione di oak-run che corrisponde alla tua versione core di oak da [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. Per ripristinare l’ultimo buono stato di un archivio di segmenti corrotto nella directory di lavoro di CQ (quella contenente la cartella crx-quickstart) e eseguire il backup di tutti i file in ./crx-quickstart/repository/segmentstore/.
3. Esegui il controllo di coerenza, java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/repository/segmentstore Questa ricerca indietro attraverso le revisioni fino a che non ne trova una coerente: Cerca un messaggio come quello che segue: INFO principale o.a.j.o.p.s.f.t.ConsistencyChecker - Trovata l&#39;ultima buona revisione afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. Ripristina l’archivio a questa revisione modificando ./crx-quickstart/repository/segmentstore/journal.log ed eliminazione di tutte le righe dopo la riga contenente l&#39;ultima revisione valida.
5. Rimuovi tutto ./crx-quickstart/repository/segmentstore/\*.bak file.
6. Esegui la pulizia dei checkpoint per rimuovere i checkpoint orfani con il seguente comando: java -Xmx6000m -jar oak-run-\*.jar checkpoint /path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. Infine, compatta l&#39;archivio: java -Xmx6000m -jar oak-run-\*.jar compatto /path/to/crx-quickstart/repository/segmentstore/




*Ci possono essere casi in cui il controllo di esecuzione oak non è in grado di trovare la buona revisione e otteniamo &quot;ConsistencyChecker - Non è stata trovata una buona revisione&quot; durante l&#39;esecuzione del comando di controllo.*
<b>Come correggere la corruzione quando si incontra &quot;ConsistencyChecker - Non è stata trovata una buona revisione&quot; sul controllo di coerenza</b>


<b>B. Rimuovere manualmente i nodi danneggiati.</b>

In AEM, le impostazioni TarMK senza FileDatastore configurato e le situazioni in cui la corruzione è nei binari, puoi fare quanto segue.

\*Attenzionen:\*La procedura seguente è destinata agli utenti che utilizzano l&#39;alimentazione.  Quando si eliminano i nodi corrotti è necessario assicurarsi che non siano nodi di sistema (come /home, /jcr:system, ecc.) .  Oppure, se si tratta di nodi di sistema, è necessario assicurarsi di poterli ripristinare.  Se non sei sicuro, consulta AEM team di Assistenza clienti per assistenza sui passaggi qui documentati.



1. AEM.
2. Utilizza la console di esecuzione Oak e carica lo script childCount groovy per identificare i nodi corrotti nell&#39;archivio segmenti:


Carica la shell della console di oak-run:

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Esegui i due comandi seguenti nella shell per caricare lo script ed eseguirlo:

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

Questo si traduce nel seguente output che indica il percorso dei nodi danneggiati:

21:21:42.029 ERRORE principale o.a.j.o.p.segment.SegmentTracker - Segmento non trovato: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. L&#39;intervallo della data di creazione è di 3 ms.

avviso non in grado di leggere il nodo /content/dam/test.txt/jcr:content/renditions/original/jcr:content

In alcuni casi il problema è collegato a proprietà binarie e lo script groovy childCount non è in grado di individuare i nodi danneggiati.  In questi casi è possibile utilizzare il seguente comando che leggerà i primi 1024 byte per ogni binario rilevato durante l&#39;attraversamento (Nota che questo comando sarà più lento e dovrebbe essere utilizzato solo quando quello sopra non restituisce i risultati previsti):

countNodes(session.workingNode,true)

3. Rimuovi tutti i nodi danneggiati identificati elencati nell&#39;output dell&#39;ultimo comando utilizzando rmNodes.groovy

Carica la shell della console di oak-run utilizzando il comando seguente:

java -jar oak-run-\*.jar console crx-quickstart/repository/segmentstore

Carica lo script groovy:

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

Esegui il comando rmNode per rimuovere il nodo corrotto, sostituisci /path/to/corrotto/node con il percorso del nodo corrotto che devi rimuovere.

rmNode(session, &quot;/path/to/corrotto/node&quot;)

Dove il percorso del nodo corrotto è il percorso ottenuto al passaggio 2, ad esempio: &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot; Nota: Quando utilizzi oak-run.jar versione 1.6.13 e successive, imposta il parametro JVM —read-write se si verifica un errore come:

/ rmNode(session,&quot;/path/to/corrotto/node&quot;) Rimozione del nodo /path/to/corrotto/node ERROR java.lang.UnsupportedOperationException:    Non è possibile scrivere nell&#39;archivio di sola lettura su org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) su org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) su org.apache.jackrabbit.oak segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111) su org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581) su org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge mentNodeStore.java:333) su org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Sorgente sconosciuta) su groovysh_evaluate.rmNode (groovysh_evaluate:11)

4. Ripetere il passaggio 3 per tutti i nodi trovati al passaggio 2.

Questo comando rmNode di cui sopra deve restituire true per il percorso corrotto, il che significa che lo ha eliminato. Assicurati che questi tre percorsi corrotti trovati vengano eliminati eseguendo nuovamente il comando rmNode su quei percorsi. L&#39;esecuzione successiva deve restituire false.

Se vedi ancora che gli stessi percorsi sono presenti nell&#39;archivio, utilizza la versione patched del jar oak-run, cioè oak-run-1.2.18-NPR-17596

Cosa fa la versione patched di Oak run Jar?

Questa versione di jar salta i binari illeggibili sulla compattazione sostituendoli con binari a 0 byte e registrando l&#39;eccezione e il percorso di syserr. L&#39;archivio così compattato dovrebbe quindi passare il controllo oak-run, lo script di conteggio dei nodi e dovresti anche essere in grado di compattarlo di nuovo utilizzando un oak-run non patched.

5. Esegui una pulizia dei checkpoint elencando i checkpoint utilizzando di seguito. Se sono presenti più punti di controllo, puliscili:

nohup java -Xmx4096m -jar punti di controllo oak-run-1.2.18.jar /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &amp;

6. Esegui una compattazione offline.  Se non sai come eseguire la compattazione offline, vedi [qui](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. Avvia il server in attesa del completamento dell&#39;indicizzazione.
